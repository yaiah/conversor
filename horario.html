<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planejador de Horário de Aulas | Yaiah</title>
    <meta name="description" content="Planeje a grade de horário de aulas online de forma fácil e gratuita. PLanejador de horários de disciplinas, turmas e atividades acadêmicas">

    <meta name="keywords" content="planejador de horário de aulas, criador de horário de aulas, montar horário de aulas, organizador de aulas, grade de horários, horário escolar, aulas, disciplinas, turmas, organização escolar, grátis, online">

    <meta name="" content="Yaiah (ou o nome do desenvolvedor/organização)">

    <meta name="robots" content="index, follow">
    <meta http-equiv="content-language" content="pt-BR">

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta property="og:title" content="Planejador de Horário de Aulas Online Gratuito">
    <meta property="og:description" content="Crie e personalize horário de aulas de sua escola online de forma fácil e gratuita. Organize seus horários de disciplinas, turmas e atividades acadêmicas">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://seusite.com.br/planejador-horario-aulas">
    <meta property="og:image" content="https://seusite.com.br/imagens/logo-planejador-aulas.png">
    <meta property="og:locale" content="pt_BR">
    <meta property="og:site_name" content="Nome do Seu Site">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Planejador de Horário de Aulas Online Gratuito">
    <meta name="twitter:description" content="Crie e personalize horário de aulas online de forma fácil e gratuita. Organize seus horários de disciplinas, turmas e atividades acadêmicas.">
    <meta name="twitter:image" content="https://seusite.com.br/imagens/logo-planejador-aulas.png">


    <!-- Include SheetJS for Excel export -->
    <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
    <!-- Include jsPDF for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <style>
        :root {
            --header-bg: #004d4d;
            --header-text: #004D4D;
            --nav-bg: #003333;
            --cell-bg: #f4f4f4;
            --cell-border: #cccccc;
            --pinned-bg: #fff8e1;
            --pinned-border: #ffc107;
            --hover-bg: #e8f5e9;
            --delete-color: #ff5252;
            --empty-bg: #ffffff;
        }
        
        body, html {
            height: 100%;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 0;
        }
        
        header {
            background-color: var(--header-bg);
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            height: 45px;
        }
        
        h1 {
            color: white;
            text-align: center;
            margin: 0;
            padding: 15px 0;
            font-size: 1.5rem;
        }
        
        nav {
            background-color: var(--nav-bg);
            padding: 10px;
        }
        
        nav ul {
            list-style-type: none;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        nav ul li {
            margin: 0 15px;
        }
        
        nav ul li a {
            color: white;
            text-decoration: none;
            font-size: 16px;
            padding: 5px 0;
            display: block;
        }
        
        nav ul li a:hover {
            text-decoration: underline;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background-color: var(--nav-bg);
            color: white;
            margin: 20px 0;
        }
        
        button {
            padding: 8px 16px;
            background-color: var(--header-bg);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background-color: #333;
        }
        
        .export-buttons {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            justify-content: center;
        }
        
        .export-btn {
            padding: 10px 15px;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .export-btn.excel {
            background-color: #217345;
        }
        
        .export-btn.pdf {
            background-color: #006666;
        }
        
        .export-btn:hover {
            opacity: 0.9;
        }
        
        .schedule-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 1px;
            background-color: var(--cell-border);
            border: 1px solid var(--cell-border);
            margin: 20px;
        }
        
        .header {
            background-color: var(--nav-bg);
            color: var(--header-text);
            font-weight: bold;
            padding: 12px;
            text-align: center;
        }
        
        .time-header {
            background-color: var(--nav-bg);
            color: var(--header-text);
            font-weight: bold;
            padding: 12px;
            text-align: center;
        }
        
        .cell {
            background-color: white;
            min-height: 100px;
            padding: 8px;
            position: relative;
        }
        
        .cell.empty {
            background-color: var(--empty-bg);
            color: white;
            border: 1px dashed #cccccc;
        }
        
        .cell.pinned {
            background-color: var(--pinned-bg);
            border: 2px solid var(--pinned-border);
        }
        
        .cell-content {
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .class-name {
            font-weight: 500;
            margin-bottom: 5px;
            word-break: break-word;
        }
        
        .cell-actions {
            display: flex;
            justify-content: flex-end;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        .cell-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 12px;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .pin-btn { color: #ff9800; }
        .edit-btn { color: #2196f3; }
        .delete-btn { color: var(--delete-color); }
        .duplicate-btn { color: #4caf50; }
        
        .color-picker {
            width: 20px;
            height: 20px;
            border: 1px solid #ccc;
            border-radius: 3px;
            cursor: pointer;
            padding: 0;
        }
        
        .time-edit {
            font-size: 12px;
            color: #004d4d;
            cursor: pointer;
            margin-top: 5px;
            text-decoration: underline;
        }
        
        .instructions {
            margin: 20px;
            padding: 15px;
            background-color: white;
            border: 1px solid #ddd;
        }
        
        footer {
            background-color: #333;
            color: white;
            text-align: center;
            padding: 10px;
            margin-top: 20px;
        }
        
        @media (max-width: 768px) {
            nav ul {
                flex-direction: column;
                align-items: center;
            }
            
            nav ul li {
                margin: 5px 0;
            }
            
            .schedule-grid {
                grid-template-columns: repeat(1, 1fr);
                margin: 10px;
            }
            
            .export-buttons {
                flex-direction: column;
                align-items: center;
            }
    .conflict-highlight {
        background-color: #ffe0e0 !important; /* Vermelho claro */
        color: black; /* Garante que o texto seja legível */
        font-weight: bold;
    }

    .conflict-highlight::after {
        content: " CONFLITO";
        font-size: 0.8em;
        color: red;
    }
}
        
    </style>
</head>
<body>
    <header>
        <img src="https://yaiah.github.io/conversor/logoyaiah2.png" alt="Yaiah" class="logo">
        <h1>Agenda Escolar</h1>
        <div></div> <!-- Empty div for spacing -->
    </header>
    
    <nav>
        <ul>
            <li><a href="index.html">Início</a></li>
            <li><a href="horario.html">App grade de aulas</a></li>
            <li><a href="sobre.html">Sobre</a></li>
            <li><a href="#">Contato</a></li>
            <li><a href="doacao.html">Doe</a></li>
        </ul>
    </nav>
    
    <div class="container">
        <div class="controls">
            <button id="add-schedule-btn">Adicionar Nova Agenda</button>
            <button id="reset-btn">Reiniciar Agenda Atual</button>
            <div id="status">Aulas agendadas: 0</div>
        </div>
        
        <div class="export-buttons">
            <button class="export-btn excel" id="export-excel">
                <span>Exportar para Excel</span>
            </button>
            <button class="export-btn pdf" id="export-pdf">
                <span>Exportar para PDF</span>
            </button>
        </div>    
    
        
    <div id="schedules-container">
        </div>
        <div class="instructions">
            <h3>Como usar esta agenda:</h3>
            <ul>
                <li><strong>Clique duas vezes</strong> para editar o nome da aula ou horário</li>
                <li><strong>📌</strong> Travar aula | <strong>✏️</strong> Editar | <strong>🗑️</strong> Excluir | <strong>⎘</strong> Duplicar</li>
                <li><strong>Arraste e solte</strong> para reorganizar</li>
                <li><strong>Seletor de cor</strong> para personalizar</li>
            </ul>
        </div>
        
        <footer>
            <p>&copy; 2023 Yaiah. Todos os direitos reservados.</p>
        </footer>
    </div>

    <script>
let scheduleCounter = 0;
const config = {
    days: ['SEGUNDA', 'TERÇA', 'QUARTA', 'QUINTA', 'SEXTA'],
    initialPeriods: 6,
    startTime: '07:00',
    timeInterval: 50, // 50 minutos de duração
    defaultColors: [
        '#F0FFF0','FCFBFA'
    ]
};

let schedules = []; // Array para armazenar todas as grades de horários
let currentScheduleIndex = 0; // Índice da grade de horários atualmente ativa
let draggedCell = null;
let colorMap = {};

// Função para criar uma nova grade de horários
function createNewSchedule() {
    scheduleCounter++; // Incrementa o contador de agendas
    const newScheduleName = `Agenda ${scheduleCounter}`; // Cria o nome da agenda

    const newSchedule = {
        id: `schedule-${Date.now()}`,
        name: newScheduleName, // Define o nome da agenda com a numeração
        scheduleData: []
    };

    const [hours, minutes] = config.startTime.split(':').map(Number);
    for (let i = 0; i < config.initialPeriods; i++) {
        const startHours = hours + Math.floor((i * config.timeInterval) / 60);
        const startMinutes = (minutes + (i * config.timeInterval) % 60);
        const start = `${Math.floor(startHours).toString().padStart(2, '0')}:${startMinutes.toString().padStart(2, '0')}`;
        const end = calculateEndTime(start);

        newSchedule.scheduleData.push({
            id: `period-${i}`,
            time: `${start} - ${end}`,
            classes: Array(config.days.length).fill().map((_, j) => ({
                id: `class-${i}-${j}`,
                name: `Aula ${i + 1}-${j + 1}`,
                pinned: false,
                color: config.defaultColors[(i + j) % config.defaultColors.length],
                professor: '',
                hasConflict: false // Inicialmente sem conflito
            }))
        });
    }

    schedules.push(newSchedule);
    currentScheduleIndex = schedules.length - 1;
    renderSchedules();
}
// Função para calcular horário de término automaticamente
    function calculateEndTime(startTime) {
        let [hours, minutes] = startTime.split(':').map(Number);
        minutes += config.timeInterval;
        hours += Math.floor(minutes / 60);
        minutes = minutes % 60;
        const endHours = Math.floor(hours); // Garante que hours seja um número inteiro
        const endMinutes = Math.floor(minutes); // Garante que minutes seja um número inteiro
        return `${endHours.toString().padStart(2, '0')}:${endMinutes.toString().padStart(2, '0')}`;
    }


// Renderizar todas as grades de horários
function renderSchedules() {
    const schedulesContainer = document.getElementById('schedules-container');
    schedulesContainer.innerHTML = ''; // Limpa o contêiner

    schedules.forEach((scheduleItem, index) => {
        const scheduleDiv = document.createElement('div');
        scheduleDiv.className = 'schedule';
        scheduleDiv.dataset.scheduleIndex = index;

        const titleElement = document.createElement('h2');
        titleElement.textContent = scheduleItem.name;
        titleElement.addEventListener('dblclick', () => editScheduleName(index));
        scheduleDiv.appendChild(titleElement);

        const grid = document.createElement('div');
        grid.className = 'schedule-grid';
        grid.id = `schedule-${scheduleItem.id}`; // ID único para cada grade
        scheduleDiv.appendChild(grid);

        initDragAndDrop(grid); // Inicializa o drag and drop para esta grade

        // Adicionar cabeçalho da grade
        grid.appendChild(createHeaderCell('')); // Canto superior esquerdo
        config.days.forEach(day => grid.appendChild(createHeaderCell(day)));

        // Criar linhas de horários para a grade atual
        scheduleItem.scheduleData.forEach((period, rowIndex) => {
            grid.appendChild(createTimeCell(period.time, rowIndex, index)); // Coluna de horários
            period.classes.forEach((cls, colIndex) => {
                grid.appendChild(cls ? createClassCell(cls, rowIndex, colIndex, index) : createEmptyCell(rowIndex, colIndex, index));
            });
        });

        const exportButtons = document.createElement('div');
        exportButtons.className = 'export-buttons';
        exportButtons.innerHTML = `
            <button class="export-btn excel" onclick="exportToExcel(${index})">
<span>Exportar para Excel</span>
</button>
<button class="export-btn pdf" onclick="exportToPDF(${index})">
    <span>Exportar para PDF</span>
</button>
        `;
        scheduleDiv.appendChild(exportButtons);

        schedulesContainer.appendChild(scheduleDiv);
    });

    updateStatus();
}

// Inicializa o drag and drop para esta grade
function initDragAndDrop(gridElement) {
    if (!gridElement) return;

    gridElement.addEventListener('dragover', e => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    });

    gridElement.addEventListener('drop', e => {
        e.preventDefault();
        if (!draggedCell) return;

        const target = e.target.closest('.cell:not(.header):not(.time-header):not(.dragging)');
        if (!target || target.classList.contains('pinned')) return;

        const sourceScheduleIndex = parseInt(draggedCell.dataset.scheduleIndex);
        const targetScheduleIndex = parseInt(target.dataset.scheduleIndex);

        if (sourceScheduleIndex !== targetScheduleIndex) return;

        const sourceRow = parseInt(draggedCell.dataset.row);
        const sourceCol = parseInt(draggedCell.dataset.col);
        const targetRow = parseInt(target.dataset.row);
        const targetCol = parseInt(target.dataset.col);

        const currentSchedule = schedules[sourceScheduleIndex];
        const sourceClass = currentSchedule.scheduleData[sourceRow]?.classes[sourceCol];
        const targetClass = currentSchedule.scheduleData[targetRow]?.classes[targetCol];

        if (!sourceClass) {
            draggedCell = null;
            return;
        }

        // Only check for conflicts if the class has a professor
        if (sourceClass.professor && sourceClass.professor.trim() !== '') {
            // Check if target time slot has conflicting professor allocation
            const conflicts = findTeacherConflicts(
                sourceClass.professor, 
                targetRow, 
                targetCol, 
                sourceScheduleIndex,
                sourceClass.id
            );

            if (conflicts.length > 0) {
                const conflictMessage = buildConflictMessage(sourceClass.professor, conflicts);
                const proceed = confirm(conflictMessage);
                if (!proceed) {
                    draggedCell = null;
                    return;
                }
            }
        }

        // Perform the actual drop operation
        if (targetClass) {
            // Swap classes
            [currentSchedule.scheduleData[sourceRow].classes[sourceCol], 
             currentSchedule.scheduleData[targetRow].classes[targetCol]] = 
            [targetClass, sourceClass];
        } else {
            // Move to empty cell
            currentSchedule.scheduleData[targetRow].classes[targetCol] = { 
                ...sourceClass,
                id: `class-${targetRow}-${targetCol}-${Date.now()}`,
                pinned: false,
                hasConflict: false // Reset conflict status
            };
            currentSchedule.scheduleData[sourceRow].classes[sourceCol] = null;
        }

        // Update conflict status for moved class
        updateConflictsAfterDrop(sourceScheduleIndex, targetRow, targetCol);
        renderSchedules();
        draggedCell = null;
    });
}
//
function findTeacherConflicts(professor, targetRow, targetCol, currentScheduleIndex, currentClassId) {
    const conflicts = [];
    const professorName = professor.trim().toLowerCase();

    schedules.forEach((schedule, scheduleIndex) => {
        // Check the target time slot in all schedules
        if (schedule.scheduleData[targetRow]?.classes[targetCol]) {
            const targetClass = schedule.scheduleData[targetRow].classes[targetCol];
            
            if (targetClass && 
                targetClass.professor && 
                targetClass.professor.trim().toLowerCase() === professorName &&
                targetClass.id !== currentClassId) {
                
                conflicts.push({
                    scheduleName: schedule.name,
                    day: config.days[targetCol],
                    time: schedule.scheduleData[targetRow].time,
                    className: targetClass.name
                });
            }
        }
    });

    return conflicts;
}

// Helper function to build conflict message
function buildConflictMessage(professor, conflicts) {
    let message = `Professor ${professor} já está alocado em:\n\n`;
    
    conflicts.forEach(conflict => {
        message += `- ${conflict.scheduleName}: ${conflict.day} às ${conflict.time} (${conflict.className})\n`;
    });
    
    message += "\nDeseja mover a aula mesmo assim?";
    return message;
}

// Update conflict status after drop
function updateConflictsAfterDrop(scheduleIndex, row, col) {
    const movedClass = schedules[scheduleIndex].scheduleData[row]?.classes[col];
    if (!movedClass || !movedClass.professor) return;

    const conflicts = findTeacherConflicts(
        movedClass.professor,
        row,
        col,
        scheduleIndex,
        movedClass.id
    );

    movedClass.hasConflict = conflicts.length > 0;
}

// Remove all other conflict checking from edit functions
function editClassName(classId, scheduleIndex) {
    const cls = findClassById(classId, scheduleIndex);
    if (!cls) return;

    const newName = prompt('Nome da aula:', cls.name);
    if (newName && newName.trim()) {
        cls.name = newName.trim();
        const professorName = prompt('Nome do professor (opcional):', cls.professor);
        if (professorName !== null) {
            cls.professor = professorName.trim();
            // No automatic conflict checking here
        }
        if (colorMap[cls.name]) cls.color = colorMap[cls.name];
        renderSchedules();
    }
}

// Criar célula de cabeçalho
function createHeaderCell(text) {
    const cell = document.createElement('div');
    cell.className = 'cell header';
    cell.textContent = text;
    return cell;
}

// Criar célula de horário
function createTimeCell(time, rowIndex, scheduleIndex) {
    const cell = document.createElement('div');
    cell.className = 'cell time-header';
    cell.dataset.row = rowIndex;
    cell.dataset.scheduleIndex = scheduleIndex;

    const [start, end] = time.split(' - ');
    cell.innerHTML = `
        <div>${start} - ${end}</div>
        <div class="time-edit">Editar Horário</div>
    `;

    // Editar com duplo-clique ou clique no texto
    cell.addEventListener('dblclick', () => editTimeSlot(rowIndex, scheduleIndex));
    cell.querySelector('.time-edit').addEventListener('click', (e) => {
        e.stopPropagation();
        editTimeSlot(rowIndex, scheduleIndex);
    });

    return cell;
}

// Criar célula vazia
function createEmptyCell(row, col, scheduleIndex) {
    const cell = document.createElement('div');
    cell.className = 'cell empty';
    cell.dataset.row = row;
    cell.dataset.col = col;
    cell.dataset.scheduleIndex = scheduleIndex;
    return cell;
}


// Criar célula de aula
function createClassCell(cls, row, col, scheduleIndex) {
    const cell = document.createElement('div');
    cell.className = `cell ${cls.pinned ? 'pinned' : ''} ${cls.hasConflict ? 'conflict-highlight' : ''}`; // Adiciona a classe de conflito
    cell.dataset.row = row;
    cell.dataset.col = col;
    cell.dataset.id = cls.id;
    cell.dataset.scheduleIndex = scheduleIndex;
    cell.style.backgroundColor = cls.color;
    cell.draggable = !cls.pinned;
    cell.title = cls.professor ? `Professor: ${cls.professor}` : '';
    console.log(cls)
    cell.innerHTML = `
        <div class="cell-content">
            <div class="class-name">${cls.name}</div>
<div class\="cell\-actions"\>
<button class="cell-btn pin-btn" title="${cls.pinned ? 'Destravar' : 'Travar'}">${cls.pinned ? '🔒' : '📌'}</button>
<button class="cell-btn edit-btn" title="Editar">✏️</button>
<button class="cell-btn delete-btn" title="Excluir">🗑️</button>
<button class="cell-btn duplicate-btn" title="Duplicar">⎘</button>
<input type="color" class="color-picker" value="${cls.color}" title="Mudar cor">
            </div>
        </div>
        ${cls.pinned ? '' : '<div class="drag-handle" title="Arrastar">↔</div>'}
    `;

    // Event listeners (permanecem os mesmos)
    cell.addEventListener('dblclick', () => editClassName(cls.id, scheduleIndex));
    cell.querySelector('.pin-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        togglePin(cls.id, scheduleIndex);
    });
    cell.querySelector('.edit-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        editClassName(cls.id, scheduleIndex);
    });
    cell.querySelector('.delete-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        deleteClass(cls.id, scheduleIndex);
    });
    cell.querySelector('.duplicate-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        duplicateClass(cls.id, scheduleIndex);
    });
    cell.querySelector('.color-picker').addEventListener('change', (e) => {
        changeClassColor(cls.id, e.target.value, scheduleIndex);
    });

    if (!cls.pinned) {
        cell.addEventListener('dragstart', handleDragStart);
        cell.addEventListener('dragend', handleDragEnd);
    }

    return cell;
}


// Editar o nome da grade de horários
function editScheduleName(scheduleIndex) {
    const newName = prompt('Novo nome para a agenda:', schedules[scheduleIndex].name);
    if (newName && newName.trim()) {
        schedules[scheduleIndex].name = newName.trim();
        renderSchedules();
    }
}

// Editar horário
function editTimeSlot(rowIndex, scheduleIndex) {
    const period = schedules[scheduleIndex].scheduleData[rowIndex];
    const [currentStart] = period.time.split(' - ');

    const newStartTime = prompt('Novo horário de início (HH:MM):', currentStart);
    if (!newStartTime || !newStartTime.match(/^\d{2}:\d{2}$/)) return;

    const newEndTime = calculateEndTime(newStartTime);
    period.time = `${newStartTime} - ${newEndTime}`;
    renderSchedules();
}

// Editar nome da aula
function editClassName(classId, scheduleIndex) {
    const cls = findClassById(classId, scheduleIndex);
    if (!cls) return;

    const newName = prompt('Nome da aula:', cls.name);
    if (newName && newName.trim()) {
        cls.name = newName.trim();
        const professorName = prompt('Nome do professor (opcional):', cls.professor);
        if (professorName !== null) {
            cls.professor = professorName.trim();
        }
        if (colorMap[cls.name]) cls.color = colorMap[cls.name];
        renderSchedules();
    }
}
//checking conflicts when adding a new class
function checkNewClassConflict(newClass, scheduleIndex, rowIndex, colIndex) {
    if (!newClass.professor || newClass.professor.trim() === '') {
        return true; // No professor, no conflict
    }
    
    return checkForTeacherConflict(newClass, scheduleIndex, rowIndex, colIndex);
}

// Mudar cor da aula
function changeClassColor(classId, color, scheduleIndex) {
    const cls = findClassById(classId, scheduleIndex);
    if (cls) {
        cls.color = color;
        colorMap[cls.name] = color;
        renderSchedules();
    }
}

// Alternar pino
function togglePin(classId, scheduleIndex) {
    const cls = findClassById(classId, scheduleIndex);
    if (cls) {
        cls.pinned = !cls.pinned;
        renderSchedules();
    }
}

// Excluir aula
function deleteClass(classId, scheduleIndex) {
    if (confirm("Tem certeza que deseja excluir esta aula?")) {
        const currentSchedule = schedules[scheduleIndex].scheduleData;
        for (const period of currentSchedule) {
            const index = period.classes.findIndex(c => c?.id === classId);
            if (index !== -1) {
                period.classes[index] = null;
                break;
            }
        }
        renderSchedules();
    }
}

// Duplicar aula
function duplicateClass(classId, scheduleIndex) {
    const original = findClassById(classId, scheduleIndex);
    if (!original) return;

    const currentScheduleData = schedules[scheduleIndex].scheduleData;
    let duplicated = false;

    // Encontra próxima vaga vazia na agenda atual
    for (let row = 0; row < currentScheduleData.length; row++) {
        for (let col = 0; col < config.days.length; col++) {
            if (!currentScheduleData[row].classes[col]) {
                currentScheduleData[row].classes[col] = {
                    ...original,
                    id: `class-${row}-${col}-${Date.now()}`,
                    pinned: false,
                    professor: original.professor, // Mantém o professor original na duplicação
                    hasConflict: original.hasConflict // Copia o status de conflito
                };

                 if (newClass.professor) {
                    newClass.hasConflict = !checkNewClassConflict(newClass, scheduleIndex, row, col);
                }

                currentScheduleData[row].classes[col] = newClass
                duplicated = true;
                break;
            }
        }
        if (duplicated) break;
    }

    // Se não encontrou vaga, adiciona nova linha na agenda atual
    if (!duplicated) {
        addTimeSlot(scheduleIndex);
        // A duplicação ocorrerá na próxima renderização
    }

    renderSchedules();
}

// Adicionar novo horário a uma grade específica
function addTimeSlot(scheduleIndex) {
    const currentScheduleData = schedules[scheduleIndex].scheduleData;
    const last = currentScheduleData[currentScheduleData.length - 1];
    const [lastStart] = last.time.split(' - ');
    const newStart = calculateEndTime(lastStart);
    const newEnd = calculateEndTime(newStart);

    currentScheduleData.push({
        id: `period-${currentScheduleData.length}`,
        time: `${newStart} - ${newEnd}`,
        classes: Array(config.days.length).fill().map((_, i) => ({
            id: `class-${currentScheduleData.length}-${i}-${Date.now()}`,
            name: `Nova Aula`,
            pinned: false,
            color: config.defaultColors[(currentScheduleData.length + i) % config.defaultColors.length],
            professor: '',
            hasConflict: false
        }))
    });

    renderSchedules();
}
//Checar conflito de horário na alocação do professor
function checkForTeacherConflict(currentClass, currentScheduleIndex, currentRowIndex, currentColIndex) {
    // If no professor assigned, no conflict possible
    if (!currentClass.professor || currentClass.professor.trim() === '') {
        return true;
    }

    const currentProfessor = currentClass.professor.trim().toLowerCase();
    let hasConflict = false;
    let conflictDetails = [];

    // Check all schedules
    schedules.forEach((schedule, scheduleIndex) => {
        // Check all periods in the schedule
        schedule.scheduleData.forEach((period, rowIndex) => {
            // Check all classes in the period
            period.classes.forEach((cls, colIndex) => {
                if (cls && cls.professor && cls.professor.trim().toLowerCase() === currentProfessor) {
                    // Skip the current class being edited
                    if (scheduleIndex === currentScheduleIndex && 
                        rowIndex === currentRowIndex && 
                        colIndex === currentColIndex) {
                        return;
                    }

                    // Found a conflict
                    hasConflict = true;
                    conflictDetails.push({
                        scheduleName: schedule.name,
                        day: config.days[colIndex],
                        time: period.time,
                        className: cls.name
                    });
                }
            });
        });
    });

    if (hasConflict) {
        let conflictMessage = "Conflito de horário detectado para o professor:\n\n";
        conflictMessage += `Professor: ${currentClass.professor}\n\n`;
        conflictMessage += "Já está alocado nos seguintes horários:\n";
        
        conflictDetails.forEach(conflict => {
            conflictMessage += `- ${conflict.scheduleName}: ${conflict.day} às ${conflict.time} (${conflict.className})\n`;
        });
        
        conflictMessage += "\nDeseja continuar com a alocação mesmo assim?";
        return confirm(conflictMessage);
    }

    return true; // No conflict found
}

// Reiniciar agenda atual
function resetSchedule() {
    if (confirm("Tem certeza que deseja reiniciar a agenda atual?")) {
        const currentSchedule = schedules[currentScheduleIndex];
        currentSchedule.scheduleData = [];
        const [hours, minutes] = config.startTime.split(':').map(Number);

        for (let i = 0; i < config.initialPeriods; i++) {
            const startHours = hours + Math.floor((i * config.timeInterval) / 60);
            const startMinutes = (minutes + (i * config.timeInterval) % 60).toString().padStart(2, '0');
            const start = `<span class="math-inline">\{startHours\}\:</span>{startMinutes}`;
            const end = calculateEndTime(start);

            currentSchedule.scheduleData.push({
                id: `period-${i}`,
                time: `${start} - ${end}`,
                classes: Array(config.days.length).fill().map((_, j) => ({
                    id: `class-<span class="math-inline">\{i\}\-</span>{j}`,
                    name: `Aula <span class="math-inline">\{i\+1\}\-</span>{j+1}`,
                    pinned: false,
                    color: config.defaultColors[(i + j) % config.defaultColors.length]
                }))
            });
        }
        colorMap = {};
        renderSchedules();
    }
}

// Encontrar aula por ID em uma grade específica
function findClassById(id, scheduleIndex) {
    const currentSchedule = schedules[scheduleIndex].scheduleData;
    for (const period of currentSchedule) {
        const cls = period.classes.find(c => c?.id === id);
        if (cls) return cls;
    }
    return null; // Retorna null se a aula não for encontrada
}

// Drag and drop
    function handleDragStart(e) {
    const draggedElement = e.target.closest('.cell:not(.header):not(.time-header):not(.pinned)');
    if (!draggedElement) return;

    draggedCell = {
        element: draggedElement,
        id: draggedElement.dataset.id,
        scheduleIndex: parseInt(draggedElement.dataset.scheduleIndex),
        row: parseInt(draggedElement.dataset.row),
        col: parseInt(draggedElement.dataset.col)
    };
    
    draggedElement.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', draggedCell.id);
}

    function handleDragEnd() {
        document.querySelectorAll('.cell.dragging').forEach(c => c.classList.remove('dragging'));
        draggedCell = null;
    }

    function initDragAndDrop(gridElement) {
        if (!gridElement) return;

        gridElement.addEventListener('dragover', e => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        });

        gridElement.addEventListener('drop', e => {
        e.preventDefault();
        if (!draggedCell) return;

        const target = e.target.closest('.cell:not(.header):not(.time-header):not(.dragging)');
        if (!target || target.classList.contains('pinned')) return;

        const targetScheduleIndex = parseInt(target.dataset.scheduleIndex);
        const targetRow = parseInt(target.dataset.row);
        const targetCol = parseInt(target.dataset.col);

        // Verify we're working with the same schedule
        if (draggedCell.scheduleIndex !== targetScheduleIndex) return;

        // Get the class data
        const sourceClass = findClassById(draggedCell.id, draggedCell.scheduleIndex);
        if (!sourceClass) return;

        // Only check for conflicts if professor exists
        if (sourceClass.professor && sourceClass.professor.trim() !== '') {
            // Find all classes in the target time slot across all schedules
            const conflicts = [];
            
            schedules.forEach((schedule, scheduleIdx) => {
                const period = schedule.scheduleData[targetRow];
                if (!period) return;
                
                const targetSlotClass = period.classes[targetCol];
                if (targetSlotClass && 
                    targetSlotClass.professor && 
                    targetSlotClass.professor.trim().toLowerCase() === sourceClass.professor.trim().toLowerCase() &&
                    targetSlotClass.id !== sourceClass.id) {
                    
                    conflicts.push({
                        scheduleName: schedule.name,
                        day: config.days[targetCol],
                        time: period.time,
                        className: targetSlotClass.name
                    });
                }
            });

            if (conflicts.length > 0) {
                // Build conflict message
                let conflictMessage = `CONFLITO: Professor ${sourceClass.professor} já está alocado em:\n\n`;
                conflicts.forEach(conflict => {
                    conflictMessage += `• ${conflict.scheduleName}: ${conflict.day} às ${conflict.time} (${conflict.className})\n`;
                });
                conflictMessage += "\nDeseja mover a aula mesmo assim?";
                
                // Show confirmation dialog
                const proceed = confirm(conflictMessage);
                if (!proceed) {
                    draggedCell = null;
                    return;
                }
            }
        }

        // Perform the actual drop operation
        const targetClass = schedules[targetScheduleIndex].scheduleData[targetRow].classes[targetCol];
        
        if (targetClass) {
            // Swap classes
            const temp = {...sourceClass};
            schedules[draggedCell.scheduleIndex].scheduleData[draggedCell.row].classes[draggedCell.col] = targetClass;
            schedules[targetScheduleIndex].scheduleData[targetRow].classes[targetCol] = temp;
        } else {
            // Move to empty cell
            schedules[targetScheduleIndex].scheduleData[targetRow].classes[targetCol] = {...sourceClass};
            schedules[draggedCell.scheduleIndex].scheduleData[draggedCell.row].classes[draggedCell.col] = null;
        }

        // Update conflict status
        updateAllConflicts();
        renderSchedules();
        draggedCell = null;
    });
}

//function to update all conflicts
function updateAllConflicts() {
    // Clear all conflict flags first
    schedules.forEach(schedule => {
        schedule.scheduleData.forEach(period => {
            period.classes.forEach(cls => {
                if (cls) cls.hasConflict = false;
            });
        });
    });

    // Now check for actual conflicts
    const professorMap = {};
    
    schedules.forEach((schedule, sIdx) => {
        schedule.scheduleData.forEach((period, pIdx) => {
            period.classes.forEach((cls, cIdx) => {
                if (cls && cls.professor && cls.professor.trim() !== '') {
                    const key = `${pIdx}-${cIdx}-${cls.professor.trim().toLowerCase()}`;
                    
                    if (!professorMap[key]) {
                        professorMap[key] = [];
                    }
                    professorMap[key].push({
                        scheduleIndex: sIdx,
                        periodIndex: pIdx,
                        classIndex: cIdx,
                        class: cls
                    });
                    
                    // If we have more than one class for this professor in the same time slot
                    if (professorMap[key].length > 1) {
                        professorMap[key].forEach(entry => {
                            schedules[entry.scheduleIndex]
                                .scheduleData[entry.periodIndex]
                                .classes[entry.classIndex]
                                .hasConflict = true;
                        });
                    }
                }
            });
        });
    });
}

//##########################
// Atualizar status
function updateStatus() {
    let count = 0;
    if (schedules[currentScheduleIndex] && schedules[currentScheduleIndex].scheduleData) {
        count = schedules[currentScheduleIndex].scheduleData.reduce((sum, period) => sum + period.classes.filter(Boolean).length, 0);
    }
    document.getElementById('status').textContent = `Aulas agendadas: ${count}`;
}

// Exportar para Excel da grade específica
function exportToExcel(scheduleIndex) {
        const scheduleItem = schedules[scheduleIndex];
        if (!scheduleItem || !scheduleItem.scheduleData) return;

        const data = [];
        const headers = ['Horário', ...config.days];
        data.push(headers);

        scheduleItem.scheduleData.forEach(period => {
            const row = [period.time];
            period.classes.forEach(cls => {
                row.push(cls ? cls.name : '(Vazio)');
            });
            data.push(row);
        });

        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(data);
        XLSX.utils.book_append_sheet(wb, ws, scheduleItem.name || "Agenda Escolar");
        XLSX.writeFile(wb, `${scheduleItem.name || "agenda_escolar"}.xlsx`);
    }

    // Exportar para PDF da grade específica
    function exportToPDF(scheduleIndex) {
        const scheduleItem = schedules[scheduleIndex];
        if (!scheduleItem || !scheduleItem.scheduleData) return;

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ orientation: 'landscape' });
        const headers = ['Horário', ...config.days];
        const data = scheduleItem.scheduleData.map(period => {
            const row = [period.time];
            period.classes.forEach(cls => {
                row.push(cls ? cls.name : '(Vazio)');
            });
            return row;
        });

        doc.setFontSize(18);
        doc.text(scheduleItem.name || 'Agenda Escolar', 14, 15);
        doc.setFontSize(12);
        doc.text(`Gerado em: ${new Date().toLocaleDateString()}`, 14, 22);

        doc.autoTable({
            head: [headers],
            body: data,
            startY: 30,
            theme: 'grid',
            headStyles: { fillColor: [0, 77, 77], textColor: 255 },
            alternateRowStyles: { fillColor: [244, 244, 244] },
            margin: { top: 30 }
        });

        doc.save(`${scheduleItem.name || 'agenda_escolar'}.pdf`);
    }

//##########################

function init() {
    createNewSchedule(); // Cria a primeira grade ao carregar
    document.getElementById('add-schedule-btn').addEventListener('click', createNewSchedule);
    document.getElementById('reset-btn').addEventListener('click', resetSchedule);
    
    document.addEventListener('dragstart', handleDragStart);
    document.addEventListener('dragend', handleDragEnd);
}

init();    
    </script>
</body>
</html>
